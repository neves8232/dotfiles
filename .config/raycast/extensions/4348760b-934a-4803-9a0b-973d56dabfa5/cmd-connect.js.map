{
  "version": 3,
  "sources": ["../src/cmd-connect.tsx", "../src/sesh.ts", "../src/env.ts", "../src/app.ts"],
  "sourcesContent": ["import { useState, useEffect } from \"react\";\n\nimport {\n  Icon,\n  List,\n  Action,\n  ActionPanel,\n  closeMainWindow,\n  clearSearchBar,\n  showToast,\n  Toast,\n  Color,\n} from \"@raycast/api\";\nimport { getSessions, connectToSession, isTmuxRunning, Session } from \"./sesh\";\nimport { openApp } from \"./app\";\n\nfunction getIcon(session: Session) {\n  switch (session.Src) {\n    case \"tmux\":\n      return {\n        source: Icon.Bolt,\n        tintColor: session.Attached >= 1 ? Color.Green : Color.Blue,\n        tooltip: session.Attached >= 1 ? \"Attached\" : \"Detached\",\n      };\n    case \"tmuxinator\":\n      return {\n        source: Icon.Box,\n        tintColor: Color.Magenta,\n      };\n    case \"config\":\n      return {\n        source: Icon.Cog,\n        tintColor: Color.SecondaryText,\n      };\n    case \"zoxide\":\n    default:\n      return {\n        source: Icon.Folder,\n        tintColor: Color.SecondaryText,\n      };\n  }\n}\n\nfunction formatScore(score: number) {\n  if (score === 0) return undefined;\n  return String(Number.isInteger(score) ? score : score.toFixed(2));\n}\n\nexport default function ConnectCommand() {\n  const [sessions, setSessions] = useState<Array<Session>>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  async function getAndSetSessions() {\n    try {\n      const sessions = await getSessions();\n      setSessions(sessions);\n    } catch (error) {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Couldn't get sessions\",\n        message: typeof error === \"string\" ? error : \"Unknown reason\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  useEffect(() => {\n    (async () => {\n      if (!(await isTmuxRunning())) {\n        await showToast({\n          style: Toast.Style.Failure,\n          title: \"tmux isn't running\",\n          message: \"Please start tmux before using this command.\",\n        });\n        setIsLoading(false);\n        return;\n      }\n      await getAndSetSessions();\n    })();\n  }, []);\n\n  async function connect(session: string) {\n    try {\n      setIsLoading(true);\n      await connectToSession(session);\n      await openApp();\n      await closeMainWindow();\n      await clearSearchBar();\n    } catch (error) {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Couldn't connect to session\",\n        message: typeof error === \"string\" ? error : \"Unknown reason\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return (\n    <List isLoading={isLoading}>\n      {sessions.map((session, index) => {\n        const accessories = [];\n\n        if (session.Src === \"tmux\") {\n          accessories.push({\n            icon: Icon.AppWindow,\n            text: String(session.Windows),\n            tooltip: session.Windows === 1 ? \"Window\" : \"Windows\",\n          });\n        } else {\n          accessories.push({\n            text: formatScore(session.Score),\n            icon: session.Src === \"tmuxinator\" ? Icon.Box : Icon.Racket,\n            tooltip: \"Score\",\n          });\n        }\n\n        return (\n          <List.Item\n            key={index}\n            title={session.Name}\n            icon={getIcon(session)}\n            accessories={accessories}\n            actions={\n              <ActionPanel>\n                <Action title=\"Connect to Session\" onAction={() => connect(session.Name)} />\n              </ActionPanel>\n            }\n          />\n        );\n      })}\n    </List>\n  );\n}\n", "import { exec } from \"child_process\";\nimport { getEnv } from \"./env\";\n\nconst env = getEnv();\n\nexport interface Session {\n  Src: string; // tmux or zoxide\n  Name: string; // The display name\n  Path: string; // The absolute directory path\n  Score: number; // The score of the session (from Zoxide)\n  Attached: number; // Whether the session is currently attached\n  Windows: number; // The number of windows in the session\n}\n\nexport function getSessions() {\n  return new Promise<Session[]>((resolve, reject) => {\n    exec(`sesh list --json`, { env }, (error, stdout, stderr) => {\n      if (error || stderr) {\n        console.error(\"stderr \", stderr);\n        console.error(\"error \", error);\n        return reject(`Please upgrade to the latest version of the sesh CLI`);\n      }\n      const sessions = JSON.parse(stdout);\n      return resolve(sessions ?? []);\n    });\n  });\n}\n\nexport function connectToSession(session: string): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    exec(`sesh connect --switch \"${session}\"`, { env }, (error, _, stderr) => {\n      if (error || stderr) {\n        console.error(\"error \", error);\n        console.error(\"stderr \", stderr);\n        return reject(error?.message ?? stderr);\n      }\n      return resolve();\n    });\n  });\n}\n\nexport function isTmuxRunning(): Promise<boolean> {\n  return new Promise<boolean>((resolve) => {\n    exec(`tmux ls`, { env }, (error, _, stderr) => resolve(!(error || stderr)));\n  });\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport function getEnv() {\n  const { environmentPath } = getPreferenceValues<Preferences.CmdConnect>();\n\n  const patchedWithoutDuplicates = new Set([\n    ...(process.env.PATH?.split(\":\") ?? []),\n    ...(environmentPath?.split(\":\") ?? []),\n  ]);\n\n  const pathString = Array.from(patchedWithoutDuplicates).join(\":\");\n\n  const env = Object.assign({}, process.env, {\n    PATH: pathString,\n  });\n\n  return env;\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport { getEnv } from \"./env\";\n\nconst env = getEnv();\n\nexport function openApp() {\n  const { openWithApp } = getPreferenceValues<Preferences.CmdConnect>();\n  if (!openWithApp) {\n    return Promise.reject(new Error(\"No app selected\"));\n  }\n  return new Promise<void>((resolve, reject) => {\n    exec(`open -a ${openWithApp.name}`, { env }, (error, _, stderr) => {\n      if (error || stderr) return reject(error?.message ?? stderr);\n      return resolve();\n    });\n  });\n}\n"],
  "mappings": "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",
  "names": ["cmd_connect_exports", "__export", "ConnectCommand", "__toCommonJS", "import_react", "import_api", "import_child_process", "import_api", "getEnv", "environmentPath", "patchedWithoutDuplicates", "pathString", "env", "getEnv", "getSessions", "resolve", "reject", "error", "stdout", "stderr", "sessions", "connectToSession", "session", "_", "isTmuxRunning", "import_api", "import_child_process", "env", "getEnv", "openApp", "openWithApp", "resolve", "reject", "error", "_", "stderr", "import_jsx_runtime", "getIcon", "session", "formatScore", "score", "ConnectCommand", "sessions", "setSessions", "isLoading", "setIsLoading", "getAndSetSessions", "getSessions", "error", "isTmuxRunning", "connect", "connectToSession", "openApp", "index", "accessories"]
}
